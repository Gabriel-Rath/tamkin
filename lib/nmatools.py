# TAMkin is a post-processing toolkit for thermochemistry and kinetics analysis.
# Copyright (C) 2008-2009 Toon Verstraelen <Toon.Verstraelen@UGent.be>,
# Matthias Vandichel <Matthias.Vandichel@UGent.be> and
# An Ghysels <An.Ghysels@UGent.be>, Center for Molecular Modeling (CMM), Ghent
# University, Ghent, Belgium; all rights reserved unless otherwise stated.
#
# This file is part of TAMkin.
#
# TAMkin is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# In addition to the regulations of the GNU General Public License,
# publications and communications based in parts on this program or on
# parts of this program are required to cite the following five articles:
#
# "Vibrational Modes in partially optimized molecular systems.", An Ghysels,
# Dimitri Van Neck, Veronique Van Speybroeck, Toon Verstraelen and Michel
# Waroquier, Journal of Chemical Physics, Vol. 126 (22): Art. No. 224102, 2007
# DOI:10.1063/1.2737444
#
# "Cartesian formulation of the Mobile Block Hesian Approach to vibrational
# analysis in partially optimized systems", An Ghysels, Dimitri Van Neck and
# Michel Waroquier, Journal of Chemical Physics, Vol. 127 (16), Art. No. 164108,
# 2007
# DOI:10.1063/1.2789429
#
# "Calculating reaction rates with partial Hessians: validation of the MBH
# approach", An Ghysels, Veronique Van Speybroeck, Toon Verstraelen, Dimitri Van
# Neck and Michel Waroquier, Journal of Chemical Theory and Computation, Vol. 4
# (4), 614-625, 2008
# DOI:10.1021/ct7002836
#
# "Mobile Block Hessian approach with linked blocks: an efficient approach for
# the calculation of frequencies in macromolecules", An Ghysels, Veronique Van
# Speybroeck, Ewald Pauwels, Dimitri Van Neck, Bernard R. Brooks and Michel
# Waroquier, Journal of Chemical Theory and Computation, Vol. 5 (5), 1203-1215,
# 2009
# DOI:10.1021/ct800489r
#
# "Normal modes for large molecules with arbitrary link constraints in the
# mobile block Hessian approach", An Ghysels, Dimitri Van Neck, Bernard R.
# Brooks, Veronique Van Speybroeck and Michel Waroquier, Journal of Chemical
# Physics, Vol. 130 (18), Art. No. 084107, 2009
# DOI:10.1063/1.3071261
#
# TAMkin is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
#
# --

import numpy
from molmod.units import cm
from molmod.constants import lightspeed
from molmod.units import angstrom, amu, cm #kjmol, second, meter, mol, K, J
#from molmod.constants import boltzmann

###import sys, numpy, pylab, types


__all__ = [
           "load_coordinates_charmm", "load_modes_charmm",
           "calculate_overlap_nma", "calculate_overlap",
           "write_overlap",
           "get_Delta_vector",
           "calculate_sensitivity_freq",
          ]



def load_coordinates_charmm(filename):
    """Read coordinates from a standard CHARMM coordinate file."""

    # skip the lines that start with * comments
    f = open(filename,'r')
    for line in f:
        if not line.startswith("*"): break
    N = int(line.split()[0])   # nb of atoms

    # store coordinates in Nbx3 matrix
    symbols = ['']*N
    coordinates = numpy.zeros((N,3),float)
    masses = numpy.zeros(N,float)
    count = 0
    for line in f:
        words = line.split()
        symbols[count]       = words[3]
        coordinates[count,:] = numpy.array([float(word) for word in words[4:7]])*angstrom
        masses[count]        = float(words[9])*amu
        count += 1
        if count >= N: break
    f.close()
    return symbols, coordinates, masses



def load_modes_charmm(filename):
    """Read modes and frequencies from a standard CHARMM-modes-file generated by the VIBRAN module in CHARMM.
    The function returns the frequencies in atomic units and the modes (in columns).
    Charmm modes are already mass weighted and normalized.
    """
    f = file(filename)

    # skip the lines that start with * comments
    for line in f:
        if not line.strip().startswith("*"): break

    # read nb of atoms and nbfreqs (if not yet specified by user)
    words = line.split()        # the current line does not start with a *
    nbfreqs = int(words[0])
    N       = int(words[1])/3   # nb of atoms

    # skip lines with masses, 6 masses on each line
    nblines = int(numpy.ceil(N/6.0))
    masses = numpy.zeros(N,float)
    count = 0
    for line in f:
        words = line.split()
        n = len(words)
        masses[count:count+n] = numpy.array([float(word) for word in words])
        count += n
        if count >= N: break

    # read nbfreqs freqs
    CNVFRQ = 2045.5/(2.99793*6.28319)  # conversion factor, see c36a0/source/fcm/consta.fcm in charmm code
    nblines = int(numpy.ceil(nbfreqs/6.0))
    freqs = numpy.zeros(nbfreqs, float)
    countline = 0
    countfreq = 0
    for line in f:
        words = line.split()
        for word in words:
            # do conversion
            freq_sq = float(word) #squared value
            if freq_sq > 0.0:  freq =  numpy.sqrt( freq_sq)
            else:              freq = -numpy.sqrt(-freq_sq) #actually imaginary
            freqs[countfreq] = freq * CNVFRQ * lightspeed/cm # conversion factor CHARMM, put into Tamkin internal units
            countfreq += 1
        countline += 1
        if countline >= nblines: break
    if countfreq != nbfreqs:
        raise ValueError("should have read "+str(nbfreqs)+" frequencies, but read "+str(countfreq))

    # read the nbfreqs modes
    mat = numpy.zeros((3*N,nbfreqs),float)
    row = 0
    col = 0
    for line in f:
        words = line.split()
        n = len(words)
        mat[row:row+n,col] = numpy.array([float(word) for word in words])
        row += n
        if row == 3*N:
            col += 1
            row = 0

    f.close()
    return freqs, mat


def calculate_overlap_nma(nma1, nma2, filename=None):
    """Calculate overlap of modes of NMA objects, and print to file if requested."""
    overlap = calculate_overlapmatrix(nma1.modes, nma2.modes)
    if filename is not None:
        write_overlap(nma1.freqs, nma2.freqs, overlap, filename=filename)
    return overlap

def calculate_overlap(mat1, freqs1, mat2, freqs2, filename=None):
    """Calculate overlap of matrices (with corresponding frequencies), and write to file if requested."""
    overlap = calculate_overlapmatrix(mat1, mat2)
    if filename is not None:
        write_overlap(freqs1, freqs2, overlap, filename=filename)
    return overlap

def calculate_overlapmatrix(mat1, mat2):
    """Calculate overlap of matrices."""
    # check dimensions
    if mat1.shape[0] != mat2.shape[0] :
        raise ValueError("Length of columns in mat1 and mat2 should be equal, but found "+str(mat1.shape[0])+" and "+str(mat2.shape[0]) )
    # calculate overlap
    return numpy.dot(numpy.transpose(mat1), mat2)


def write_overlap(freqs1, freqs2, overlap, filename=None):
    """Write overlap matrix to a file, default is overlap.csv. Format:
    ------------------------
           | freqs2
    ------------------------
    freqs1 | mat1^T . mat2
    ------------------------
    """
    #freqs1 = freqs1 /lightspeed*cm
    #freqs2 = freqs2 /lightspeed*cm

    # write to file
    if filename==None:
        filename="overlap.csv"   # TODO sys.currentdir

    to_append="w+"   # not append, just overwrite
    f = file(filename,to_append)

    [rows,cols] = overlap.shape

    # 1. row of freqs2
    print >> f, ";"+";".join(str(g) for g in freqs2)  #this is the same

    # 2. start each row with freq of freqs1 and continue with overlaps
    for r in range(rows):
        print >> f, str(freqs1[r])+";"+";".join(str(g) for g in overlap[r,:].tolist())
    f.close()


def get_Delta_vector(coor1, coor2, masses = None, normalize = False, normthreshold = 1e-10):
    """Calculate mass weighted Delta vector between two conformations.
    It is assumed that the structures have been aligned (center of mass, orientation) previously.
    Optional:
    massweight  --  Whether Delta vector should be mass weighted. Default is True.
    normalize  --  Whether Delta vector should be normalized. Default is False."""
    # check consistency
    if len(coor1) != len(coor2):
        raise ValueError("coordinates should have same length: found "+str(len(coor1))+" and "+str(len(coor2)))

    Delta = numpy.ravel(coor1 - coor2)
    if not masses is None:  #Mass-weighting Delta vector
        for i,mass in enumerate(masses):
            Delta[3*i:3*(i+1)] *=  numpy.sqrt(mass)
    if normalize:   #Normalizing Delta vector
        norm = numpy.sum(Delta**2)
        if norm < normthreshold:
            raise ValueError("Can not normalize Delta vector, because norm (squared) it too small: "+str(norm))
        Delta /= numpy.sqrt(norm)
    return numpy.reshape(Delta, (-1,1))


#def get_Delta_vector_charmmcor(charmmcorfile1, charmmcorfile2, massweight = True, normalize = False):
#    """Calculate mass weighted Delta vector between two charmm conformations.
#    Optional:
#    massweight  --  Whether Delta vector should be mass weighted. Default is True.
#    normalize  --  Whether Delta vector should be normalized. Default is False."""
#    symb1,coor1,masses1 = read_charmm_cor(charmmcorfile1)
#    symb2,coor2,masses2 = read_charmm_cor(charmmcorfile2)
#    # check consistency
#    if not symb1 == symb2:
#        raise ValueError("not the same atom symbols in both coordinate files: comparison makes no sense.")
#    if not masses1 == masses2:
#        raise ValueError("not the same atom masses in both coordinate files: comparison makes no sense.")
#    if massweight:
#        return get_Delta_vector(coor1, coor2, masses = masses1, normalize = normalize)
#    else:
#        return get_Delta_vector(coor1, coor2, normalize = normalize)


#def get_Delta_vector_molecules(molecule1, molecule2, massweight = True, normalize = False):
#    """Calculate mass weighted Delta vector between two charmm conformations.
#    Optional:
#    massweight  --  Whether Delta vector should be mass weighted. Default is True.
#    normalize  --  Wihether Delta vector should be normalized. Default is False."""
#    # check consistency
#    if molecule1.size != molecule2.size:
#        raise ValueError("Nb of atoms is not the same in the two molecules. Found "+str(molecule1)+" (1) and "+str(molecule)+" (2).")
#    for i in range(molecule1.size):
#        if molecule1.numbers[i] != molecule2.numbers[i]:
#            raise ValueError("Atoms of molecule1 differ from those of molecule2 (different atomic numbers), but should be the same.")
#    if not molecule1.masses == molecule2.masses:
#        raise ValueError("not the same atom masses in both coordinate files: comparison makes no sense.")
#
#    if massweight:
#        return get_Delta_vector(molecule1.coordinates, molecule2.coordinates,
#                    masses = molecule1.masses, normalize = normalize)
#    else:
#        return get_Delta_vector(molecule1.coordinates, molecule2.coordinates, normalize = normalize)



def calculate_sensitivity_freq(nma, index, symmetric = False, massweight = True):
    """Calculate the sensity of the index-th frequency to changes of
    the mass-weighted Hessian elements.
    Optional:
    symmetric  --  Slightly different formula if symmetry of matrix is taken into account. Default False.
    massweight  --  Whether mass-weighted or un-mass-weighted Hessian is considered."""
    L = 3*len(nma.masses)
    mode = nma.modes[:,index]
    if not massweight: # un-mass-weight the mode
        for at,mass in enumerate(nma.masses):
            mode[3*at:3*(at+1)] /= numpy.sqrt(mass)
        mode = mode / numpy.sqrt(numpy.sum(mode**2))  # renormalization necessary

    mat = numpy.dot( numpy.reshape(mode,(L,1)), numpy.reshape(mode,(1,L)) )
    if symmetric:
        mat *= 2
        for i in range(L):
             mat[i,i] -= mode[i]**2

    return mat

